<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HCP - Stratigraphic Analysis</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #0a0a0a;
      color: #666;
      overflow-x: hidden;
    }

    #container {
      display: flex;
      height: 100vh;
    }

    #sidebar {
      width: 300px;
      background: #0a0a0a;
      border-right: 1px solid #222;
      padding: 20px;
      overflow-y: auto;
    }

    #sidebar h1 {
      font-size: 0.85em;
      font-weight: 400;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      margin-bottom: 20px;
      color: #444;
    }

    #file-input {
      width: 100%;
      margin-bottom: 30px;
      font-size: 0.75em;
    }

    .metadata {
      font-size: 0.7em;
      line-height: 1.8;
      margin-bottom: 30px;
    }

    .metadata .label {
      color: #444;
      text-transform: uppercase;
      font-size: 0.9em;
      letter-spacing: 0.1em;
    }

    .metadata .value {
      color: #888;
      margin-bottom: 10px;
    }

    .round-nav {
      font-size: 0.7em;
      margin-bottom: 15px;
    }

    .round-item {
      padding: 8px 0;
      border-bottom: 1px solid #1a1a1a;
      cursor: pointer;
      transition: color 0.2s;
    }

    .round-item:hover {
      color: #999;
    }

    .round-item .round-label {
      color: #444;
      text-transform: uppercase;
      font-size: 0.9em;
      letter-spacing: 0.1em;
    }

    .round-item .round-strategy {
      color: #666;
      margin-top: 3px;
      font-size: 0.95em;
    }

    #canvas-container {
      flex: 1;
      overflow: auto;
      position: relative;
      background: #0a0a0a;
    }

    #main-canvas {
      display: block;
      image-rendering: crisp-edges;
    }

    .legend {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid #222;
      padding: 15px;
      font-size: 0.65em;
      letter-spacing: 0.05em;
    }

    .legend-title {
      color: #444;
      text-transform: uppercase;
      margin-bottom: 10px;
      letter-spacing: 0.15em;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
      color: #666;
    }

    .legend-item:last-child {
      margin-bottom: 0;
    }

    .legend-color {
      width: 12px;
      height: 12px;
      margin-right: 8px;
      border: 1px solid #333;
    }

    .loading {
      color: #444;
      text-align: center;
      padding: 40px;
      font-size: 0.75em;
      letter-spacing: 0.15em;
      text-transform: uppercase;
    }

    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="sidebar">
      <h1>Stratigraphy</h1>

      <input type="file" id="file-input" accept=".json">

      <div id="metadata" class="metadata hidden">
        <div class="label">Performance</div>
        <div class="value" id="perf-name">-</div>

        <div class="label">Duration</div>
        <div class="value" id="perf-duration">-</div>

        <div class="label">Participants</div>
        <div class="value" id="perf-participants">-</div>

        <div class="label">Events</div>
        <div class="value" id="perf-events">-</div>
      </div>

      <div id="round-nav" class="hidden"></div>
    </div>

    <div id="canvas-container">
      <div class="loading" id="loading">Load replay file to begin analysis</div>
      <canvas id="main-canvas" class="hidden"></canvas>
    </div>
  </div>

  <div class="legend hidden" id="legend">
    <div class="legend-title">Artifacts</div>
    <div class="legend-item">
      <div class="legend-color" style="background: #1a4d4d;"></div>
      <div>Instruction (selection)</div>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #9effc7;"></div>
      <div>Fast completion (&lt;2s)</div>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #66aa88;"></div>
      <div>Medium completion (2-5s)</div>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #444444;"></div>
      <div>Slow completion (&gt;5s)</div>
    </div>
    <div class="legend-item">
      <div class="legend-color" style="background: #2a2a2a; border-color: #444;"></div>
      <div>Round boundary</div>
    </div>
  </div>

  <script>
    let replayData = null;
    let canvas = null;
    let ctx = null;

    // Analysis data
    let participantIds = [];
    let rounds = [];
    let startTime = null;
    let endTime = null;
    let totalDuration = 0;

    // Visual constants
    const PARTICIPANT_WIDTH = 4;
    const TIME_SCALE = 0.05; // pixels per millisecond
    const ROUND_SEPARATOR_HEIGHT = 40;
    const MARGIN = 60;

    // Load file
    document.getElementById('file-input').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          replayData = JSON.parse(e.target.result);
          analyzeData();
          renderVisualization();
        } catch (error) {
          console.error('Error loading replay:', error);
          alert('Error loading replay file');
        }
      };
      reader.readAsText(file);
    });

    function analyzeData() {
      console.log('Analyzing data...');

      // Extract timeline
      startTime = new Date(replayData.metadata.start_time);
      endTime = new Date(replayData.metadata.end_time);
      totalDuration = endTime - startTime;

      // Collect all unique participants from events
      const participantSet = new Set();
      replayData.events.forEach(event => {
        if (event.participant_id) {
          participantSet.add(event.participant_id);
        }
        if (event.data && event.data.participants) {
          event.data.participants.forEach(id => participantSet.add(id));
        }
      });
      participantIds = Array.from(participantSet).sort();

      // Organize events by round
      rounds = [];
      let currentRound = null;

      replayData.events.forEach(event => {
        const eventTime = new Date(event.timestamp);
        const relativeTime = eventTime - startTime;

        if (event.type === 'round_start') {
          currentRound = {
            number: event.round_number,
            strategy: event.data.strategy || '',
            observation: event.data.observation || '',
            narrative: event.data.narrative_thread || '',
            startTime: relativeTime,
            endTime: null,
            instructions: [],
            completions: [],
            reflection: '',
            sentiment: ''
          };
          rounds.push(currentRound);
        }

        if (event.type === 'instruction_sent' && currentRound) {
          currentRound.instructions.push({
            time: relativeTime,
            participants: event.data.participants || [],
            task: event.data.task || ''
          });
        }

        if (event.type === 'task_completed' && currentRound) {
          currentRound.completions.push({
            time: relativeTime,
            participantId: event.participant_id,
            completionTime: event.data.completion_time_ms
          });
        }

        if (event.type === 'round_end' && currentRound) {
          currentRound.endTime = relativeTime;
          currentRound.reflection = event.data.reflection || '';
          currentRound.sentiment = event.data.sentiment || '';
        }
      });

      // Fix any rounds without end times
      rounds.forEach((round, i) => {
        if (round.endTime === null) {
          if (i < rounds.length - 1) {
            round.endTime = rounds[i + 1].startTime;
          } else {
            round.endTime = totalDuration;
          }
        }
      });

      console.log('Analysis complete:', {
        participants: participantIds.length,
        rounds: rounds.length,
        duration: totalDuration
      });

      // Update metadata
      document.getElementById('perf-name').textContent = replayData.metadata.name;
      document.getElementById('perf-duration').textContent =
        `${(totalDuration / 1000).toFixed(1)}s`;
      document.getElementById('perf-participants').textContent = participantIds.length;
      document.getElementById('perf-events').textContent = replayData.events.length;
      document.getElementById('metadata').classList.remove('hidden');

      // Build round navigation
      const roundNav = document.getElementById('round-nav');
      roundNav.innerHTML = '';
      rounds.forEach((round, i) => {
        const item = document.createElement('div');
        item.className = 'round-item';
        item.innerHTML = `
          <div class="round-label">Round ${round.number}</div>
          <div class="round-strategy">${round.strategy.substring(0, 60)}${round.strategy.length > 60 ? '...' : ''}</div>
        `;
        item.onclick = () => scrollToRound(i);
        roundNav.appendChild(item);
      });
      document.getElementById('round-nav').classList.remove('hidden');
    }

    function renderVisualization() {
      console.log('Rendering visualization...');

      // Calculate dimensions
      const canvasWidth = MARGIN * 2 + participantIds.length * PARTICIPANT_WIDTH;
      const totalHeight = rounds.reduce((sum, round) => {
        return sum + (round.endTime - round.startTime) * TIME_SCALE + ROUND_SEPARATOR_HEIGHT;
      }, 0);
      const canvasHeight = MARGIN * 2 + totalHeight;

      // Setup canvas
      canvas = document.getElementById('main-canvas');
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      ctx = canvas.getContext('2d');

      // Clear
      ctx.fillStyle = '#0a0a0a';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);

      // Draw visualization
      let currentY = MARGIN;

      rounds.forEach((round, roundIndex) => {
        const roundDuration = round.endTime - round.startTime;
        const roundHeight = roundDuration * TIME_SCALE;

        // Round separator bar
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(0, currentY, canvasWidth, ROUND_SEPARATOR_HEIGHT);

        // Round label
        ctx.fillStyle = '#666';
        ctx.font = '10px Courier New';
        ctx.fillText(
          `ROUND ${round.number}`,
          10,
          currentY + 15
        );

        // Strategy (truncated)
        ctx.fillStyle = '#444';
        ctx.font = '9px Courier New';
        const strategyText = round.strategy.substring(0, 80);
        ctx.fillText(strategyText, 10, currentY + 30);

        currentY += ROUND_SEPARATOR_HEIGHT;

        // Draw round background
        ctx.fillStyle = roundIndex % 2 === 0 ? '#0d0d0d' : '#0a0a0a';
        ctx.fillRect(0, currentY, canvasWidth, roundHeight);

        // Draw instructions as horizontal bands
        round.instructions.forEach(instruction => {
          const instructionY = currentY + (instruction.time - round.startTime) * TIME_SCALE;

          instruction.participants.forEach(participantId => {
            const participantIndex = participantIds.indexOf(participantId);
            if (participantIndex === -1) return;

            const x = MARGIN + participantIndex * PARTICIPANT_WIDTH;

            // Instruction mark
            ctx.fillStyle = '#1a4d4d';
            ctx.fillRect(x, instructionY, PARTICIPANT_WIDTH, 3);
          });
        });

        // Draw completions as dots
        round.completions.forEach(completion => {
          const completionY = currentY + (completion.time - round.startTime) * TIME_SCALE;
          const participantIndex = participantIds.indexOf(completion.participantId);
          if (participantIndex === -1) return;

          const x = MARGIN + participantIndex * PARTICIPANT_WIDTH + PARTICIPANT_WIDTH / 2;

          // Color by speed
          let color;
          if (completion.completionTime < 2000) {
            color = '#9effc7'; // Fast
          } else if (completion.completionTime < 5000) {
            color = '#66aa88'; // Medium
          } else {
            color = '#444444'; // Slow
          }

          ctx.fillStyle = color;
          ctx.fillRect(x - 1, completionY, 2, 2);
        });

        // Draw reflection at bottom of round
        if (round.reflection) {
          const reflectionY = currentY + roundHeight - 15;
          ctx.fillStyle = '#333';
          ctx.font = '8px Courier New';
          const reflectionText = `"${round.reflection.substring(0, 100)}${round.reflection.length > 100 ? '...' : ''}"`;
          ctx.fillText(reflectionText, 10, reflectionY);
        }

        currentY += roundHeight;
      });

      // Draw participant axis labels (vertical on left)
      ctx.fillStyle = '#333';
      ctx.font = '8px Courier New';
      ctx.save();
      ctx.translate(15, MARGIN + 50);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('PARTICIPANTS →', 0, 0);
      ctx.restore();

      // Draw time axis label
      ctx.fillStyle = '#333';
      ctx.fillText('TIME ↓', canvasWidth - 80, MARGIN - 10);

      // Show canvas
      document.getElementById('loading').classList.add('hidden');
      canvas.classList.remove('hidden');
      document.getElementById('legend').classList.remove('hidden');

      console.log('Visualization complete');
    }

    function scrollToRound(roundIndex) {
      if (!canvas) return;

      // Calculate Y position of round
      let targetY = MARGIN;
      for (let i = 0; i < roundIndex; i++) {
        const roundDuration = rounds[i].endTime - rounds[i].startTime;
        targetY += roundDuration * TIME_SCALE + ROUND_SEPARATOR_HEIGHT;
      }

      // Scroll to position
      const container = document.getElementById('canvas-container');
      container.scrollTop = targetY - 100;
    }
  </script>
</body>
</html>
