<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HCP - Replay Visualizer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
    }

    #controls {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      border: 1px solid #333;
      max-width: 300px;
    }

    #controls h2 {
      font-size: 1.2em;
      font-weight: 300;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 15px;
    }

    #controls label {
      display: block;
      font-size: 0.9em;
      margin-bottom: 8px;
      opacity: 0.8;
    }

    #controls input,
    #controls select {
      width: 100%;
      padding: 8px;
      background: #1a1a1a;
      border: 1px solid #333;
      color: #fff;
      border-radius: 5px;
      font-size: 0.9em;
      margin-bottom: 15px;
    }

    #controls button {
      width: 100%;
      padding: 10px;
      background: #fff;
      border: none;
      color: #000;
      border-radius: 5px;
      font-size: 0.9em;
      font-weight: 500;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 10px;
    }

    #controls button:hover {
      background: #ddd;
    }

    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.9);
      padding: 15px 20px;
      border-radius: 10px;
      border: 1px solid #333;
      font-size: 0.85em;
      max-width: 500px;
    }

    #info .event-type {
      font-weight: 500;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 5px;
      color: #9effc7;
    }

    #info .event-details {
      opacity: 0.9;
      margin-top: 5px;
    }

    #progress-bar {
      width: 100%;
      height: 4px;
      background: #1a1a1a;
      border-radius: 2px;
      margin-top: 10px;
      overflow: hidden;
    }

    #progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #9effc7, #66ffd1);
      width: 0%;
      transition: width 0.1s linear;
    }

    .stats {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 10px;
      border: 1px solid #333;
      font-size: 0.85em;
      min-width: 200px;
    }

    .stats .stat {
      margin-bottom: 8px;
    }

    .stats .label {
      opacity: 0.7;
      margin-right: 10px;
    }

    .stats .value {
      color: #9effc7;
      font-weight: 500;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h2>Replay</h2>
    <label for="performance-select">Load Replay Log:</label>
    <input type="file" id="performance-select" accept=".json">

    <label for="speed">Playback Speed:</label>
    <input type="range" id="speed" min="0.5" max="10" step="0.5" value="2">
    <span id="speed-value" style="opacity: 0.7; font-size: 0.85em;">2x</span>

    <button id="play-pause" disabled>Play</button>
    <button id="restart" disabled>Restart</button>

    <div id="progress-bar">
      <div id="progress-fill"></div>
    </div>
  </div>

  <div class="stats hidden" id="stats">
    <div class="stat">
      <span class="label">Participants:</span>
      <span class="value" id="stat-participants">0</span>
    </div>
    <div class="stat">
      <span class="label">Current Round:</span>
      <span class="value" id="stat-round">-</span>
    </div>
    <div class="stat">
      <span class="label">Events:</span>
      <span class="value" id="stat-events">0 / 0</span>
    </div>
  </div>

  <div id="info" class="hidden">
    <div class="event-type" id="event-type"></div>
    <div class="event-details" id="event-details"></div>
  </div>

  <script>
    // Replay data
    let replayData = null;
    let currentEventIndex = 0;
    let playbackSpeed = 2;
    let isPlaying = false;
    let lastEventTime = 0;

    // Visualization objects
    let agent;
    let participants = new Map(); // clientId -> Participant object
    let connections = [];
    let ripples = [];
    let activeGroups = new Map(); // groupId -> { color, participantIds }

    // Agent class (central sun)
    class Agent {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.baseSize = 60;
        this.size = this.baseSize;
        this.pulse = 0;
      }

      update() {
        this.pulse += 0.05;
        this.size = this.baseSize + sin(this.pulse) * 8;
      }

      draw() {
        push();
        // Glow
        for (let i = 5; i > 0; i--) {
          noStroke();
          fill(255, 200, 100, 20);
          circle(this.x, this.y, this.size + i * 15);
        }
        // Core
        fill(255, 220, 150);
        noStroke();
        circle(this.x, this.y, this.size);
        fill(255, 240, 200);
        circle(this.x, this.y, this.size * 0.6);
        pop();
      }

      sendRipple() {
        ripples.push(new Ripple(this.x, this.y));
      }
    }

    // Participant class (orbiting points)
    class Participant {
      constructor(id, joinIndex) {
        this.id = id;
        this.angle = (joinIndex / 100) * TWO_PI + random(TWO_PI);  // Distribute around circle
        this.distance = 200 + random(-30, 30);
        this.targetDistance = this.distance;
        this.size = 4;
        this.targetSize = 4;
        this.color = color(150, 150, 200);
        this.targetColor = color(150, 150, 200);
        this.glow = 0;
        this.targetGlow = 0;
        this.group = null;
        this.active = false;
        this.opacity = 0;
        this.targetOpacity = 255;
      }

      setGroup(groupId, groupColor) {
        this.group = groupId;
        this.targetColor = groupColor;
        this.targetDistance = 180 + (groupId % 3) * 40;
        this.targetGlow = 100;
        this.active = true;
        this.targetSize = 6;
      }

      resetGroup() {
        this.group = null;
        this.targetColor = color(150, 150, 200);
        this.targetDistance = 200 + random(-30, 30);
        this.targetGlow = 0;
        this.active = false;
        this.targetSize = 4;
      }

      leave() {
        this.targetOpacity = 0;
      }

      update() {
        // Smooth transitions
        this.distance = lerp(this.distance, this.targetDistance, 0.05);
        this.size = lerp(this.size, this.targetSize, 0.1);
        this.glow = lerp(this.glow, this.targetGlow, 0.05);
        this.opacity = lerp(this.opacity, this.targetOpacity, 0.1);
        this.color = lerpColor(this.color, this.targetColor, 0.05);

        // Slow rotation
        this.angle += 0.001;
      }

      draw() {
        if (this.opacity < 1) return;

        const x = width / 2 + cos(this.angle) * this.distance;
        const y = height / 2 + sin(this.angle) * this.distance;

        push();
        // Glow when active
        if (this.glow > 0) {
          noStroke();
          fill(red(this.color), green(this.color), blue(this.color), this.glow * (this.opacity / 255));
          circle(x, y, this.size * 3);
        }
        // Particle
        fill(red(this.color), green(this.color), blue(this.color), this.opacity);
        noStroke();
        circle(x, y, this.size);
        pop();
      }

      getPosition() {
        return {
          x: width / 2 + cos(this.angle) * this.distance,
          y: height / 2 + sin(this.angle) * this.distance
        };
      }
    }

    // Connection class (threads between grouped participants)
    class Connection {
      constructor(p1, p2, groupColor) {
        this.p1 = p1;
        this.p2 = p2;
        this.color = groupColor;
        this.alpha = 0;
        this.targetAlpha = 60;
      }

      update() {
        this.alpha = lerp(this.alpha, this.targetAlpha, 0.05);
      }

      draw() {
        if (this.alpha < 1) return;

        const pos1 = this.p1.getPosition();
        const pos2 = this.p2.getPosition();

        push();
        stroke(red(this.color), green(this.color), blue(this.color), this.alpha);
        strokeWeight(0.5);
        line(pos1.x, pos1.y, pos2.x, pos2.y);
        pop();
      }

      fadeOut() {
        this.targetAlpha = 0;
      }

      isDead() {
        return this.alpha < 0.5 && this.targetAlpha === 0;
      }
    }

    // Ripple class (instructions emanating from agent)
    class Ripple {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 0;
        this.maxRadius = 500;
        this.alpha = 255;
        this.speed = 3;
      }

      update() {
        this.radius += this.speed;
        this.alpha = map(this.radius, 0, this.maxRadius, 255, 0);
      }

      draw() {
        if (this.radius > this.maxRadius) return;

        push();
        noFill();
        stroke(255, 220, 150, this.alpha);
        strokeWeight(2);
        circle(this.x, this.y, this.radius * 2);
        pop();
      }

      isDead() {
        return this.radius > this.maxRadius;
      }
    }

    // p5.js setup
    function setup() {
      createCanvas(windowWidth, windowHeight);
      agent = new Agent(width / 2, height / 2);
    }

    // p5.js draw loop
    function draw() {
      background(0);

      // Update and draw agent
      agent.update();
      agent.draw();

      // Update and draw participants
      for (let p of participants.values()) {
        p.update();
        p.draw();
      }

      // Update and draw connections
      connections = connections.filter(c => !c.isDead());
      for (let c of connections) {
        c.update();
        c.draw();
      }

      // Update and draw ripples
      ripples = ripples.filter(r => !r.isDead());
      for (let r of ripples) {
        r.update();
        r.draw();
      }

      // Process replay events
      if (replayData && isPlaying) {
        processEvents();
      }
    }

    // Event colors for different groups
    const groupColors = [
      color(255, 100, 100), // Red
      color(100, 255, 100), // Green
      color(100, 100, 255), // Blue
      color(255, 255, 100), // Yellow
      color(255, 100, 255), // Magenta
      color(100, 255, 255), // Cyan
    ];

    // Process events at appropriate times
    function processEvents() {
      if (!replayData || currentEventIndex >= replayData.events.length) {
        isPlaying = false;
        document.getElementById('play-pause').textContent = 'Play';
        return;
      }

      const now = millis();
      const event = replayData.events[currentEventIndex];

      // Calculate time since last event
      if (currentEventIndex > 0) {
        const prevEvent = replayData.events[currentEventIndex - 1];
        const eventDelay = (new Date(event.timestamp) - new Date(prevEvent.timestamp));
        const scaledDelay = eventDelay / playbackSpeed;

        if (now - lastEventTime < scaledDelay) {
          return; // Wait for the scaled delay
        }
      }

      // Process the event
      handleEvent(event);

      // Move to next event
      currentEventIndex++;
      lastEventTime = now;

      // Update progress
      const progress = (currentEventIndex / replayData.events.length) * 100;
      document.getElementById('progress-fill').style.width = `${progress}%`;
      document.getElementById('stat-events').textContent = `${currentEventIndex} / ${replayData.events.length}`;
    }

    // Handle individual events
    function handleEvent(event) {
      console.log('Event:', event.type, event);

      switch (event.type) {
        case 'participant_join':
          handleParticipantJoin(event);
          break;

        case 'participant_leave':
          handleParticipantLeave(event);
          break;

        case 'round_start':
          handleRoundStart(event);
          break;

        case 'instruction_sent':
          handleInstructionSent(event);
          break;

        case 'task_completed':
          handleTaskCompleted(event);
          break;

        case 'round_end':
          handleRoundEnd(event);
          break;

        case 'performance_end':
          handlePerformanceEnd(event);
          break;
      }
    }

    function handleParticipantJoin(event) {
      const participantId = event.participant_id;
      const joinIndex = participants.size;

      const participant = new Participant(participantId, joinIndex);
      participants.set(participantId, participant);

      document.getElementById('stat-participants').textContent = participants.size;

      showEventInfo('Participant Joined', `ID: ${participantId}`);
    }

    function handleParticipantLeave(event) {
      const participantId = event.participant_id;
      const participant = participants.get(participantId);

      if (participant) {
        participant.leave();
        // Remove after fade out
        setTimeout(() => {
          participants.delete(participantId);
          document.getElementById('stat-participants').textContent = participants.size;
        }, 2000);
      }

      showEventInfo('Participant Left', `ID: ${participantId}`);
    }

    let currentRound = 0;

    function handleRoundStart(event) {
      currentRound = event.round_number;
      document.getElementById('stat-round').textContent = currentRound;

      // Clear previous round groups
      fadeOutAllConnections();
      resetAllParticipants();

      const details = `
        <div><strong>Observation:</strong> ${event.data.observation || 'N/A'}</div>
        <div><strong>Strategy:</strong> ${event.data.strategy || 'N/A'}</div>
        <div><strong>Narrative:</strong> ${event.data.narrative_thread || 'N/A'}</div>
      `;

      showEventInfo(`Round ${currentRound} Start`, details);
    }

    function handleInstructionSent(event) {
      const instructionId = event.instruction_id;
      const data = event.data;
      const task = data.task;
      const groupId = data.group_id;
      const groupParticipants = data.participants || [];
      const targetPercent = data.target_percent;

      // Send ripple
      agent.sendRipple();

      // Get group color
      const groupColor = groupColors[groupId % groupColors.length];

      // Activate participants in this group
      groupParticipants.forEach(participantId => {
        const participant = participants.get(participantId);
        if (participant) {
          participant.setGroup(groupId, groupColor);
        }
      });

      // Create connections within group
      for (let i = 0; i < groupParticipants.length; i++) {
        for (let j = i + 1; j < groupParticipants.length; j++) {
          if (random() < 0.08) { // Only some connections to avoid clutter
            const p1 = participants.get(groupParticipants[i]);
            const p2 = participants.get(groupParticipants[j]);
            if (p1 && p2) {
              connections.push(new Connection(p1, p2, groupColor));
            }
          }
        }
      }

      showEventInfo('Instruction Sent', `"${task}" to ${groupParticipants.length} participants (${targetPercent}%)`);
    }

    function handleTaskCompleted(event) {
      const participantId = event.participant_id;
      const completionTime = event.data.completion_time_ms;

      const participant = participants.get(participantId);
      if (participant) {
        // Brief flash
        participant.targetGlow = 150;
        setTimeout(() => {
          if (participant.targetGlow === 150) {
            participant.targetGlow = 100;
          }
        }, 200);
      }

      showEventInfo('Task Completed', `${participantId} (${(completionTime / 1000).toFixed(1)}s)`);
    }

    function handleRoundEnd(event) {
      const roundNumber = event.round_number;
      const reflection = event.data.reflection;
      const sentiment = event.data.sentiment;

      // Fade out connections
      fadeOutAllConnections();

      showEventInfo(`Round ${roundNumber} End`, `${reflection} (${sentiment})`);
    }

    function handlePerformanceEnd(event) {
      isPlaying = false;
      document.getElementById('play-pause').textContent = 'Play';

      showEventInfo('Performance End', 'Replay complete');
    }

    function fadeOutAllConnections() {
      connections.forEach(c => c.fadeOut());
    }

    function resetAllParticipants() {
      participants.forEach(p => p.resetGroup());
    }

    function showEventInfo(type, details) {
      document.getElementById('event-type').textContent = type;
      document.getElementById('event-details').innerHTML = details;
      document.getElementById('info').classList.remove('hidden');
    }

    // Load performance from file
    document.getElementById('performance-select').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          replayData = JSON.parse(e.target.result);
          initializeReplay();
        } catch (error) {
          console.error('Error loading replay:', error);
          alert('Error loading replay file');
        }
      };
      reader.readAsText(file);
    });

    // Initialize replay with loaded data
    function initializeReplay() {
      console.log('Loaded replay:', replayData.performance_id);
      console.log('Events:', replayData.events.length);

      // Reset state
      participants.clear();
      connections = [];
      ripples = [];
      currentEventIndex = 0;
      currentRound = 0;
      isPlaying = false;
      lastEventTime = millis();

      // Update UI
      document.getElementById('stat-participants').textContent = '0';
      document.getElementById('stat-round').textContent = '-';
      document.getElementById('stat-events').textContent = `0 / ${replayData.events.length}`;
      document.getElementById('progress-fill').style.width = '0%';
      document.getElementById('stats').classList.remove('hidden');
      document.getElementById('play-pause').disabled = false;
      document.getElementById('restart').disabled = false;
      document.getElementById('play-pause').textContent = 'Play';

      showEventInfo('Replay Loaded', `${replayData.metadata.name} (${replayData.events.length} events)`);
    }

    // Controls
    document.getElementById('speed').addEventListener('input', function(e) {
      playbackSpeed = parseFloat(e.target.value);
      document.getElementById('speed-value').textContent = `${playbackSpeed}x`;
    });

    document.getElementById('play-pause').addEventListener('click', function() {
      if (!replayData) return;

      isPlaying = !isPlaying;
      this.textContent = isPlaying ? 'Pause' : 'Play';

      if (isPlaying) {
        lastEventTime = millis();
      }
    });

    document.getElementById('restart').addEventListener('click', function() {
      if (replayData) {
        initializeReplay();
      }
    });

    // Handle window resize
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      if (agent) {
        agent.x = width / 2;
        agent.y = height / 2;
      }
    }
  </script>
</body>
</html>
