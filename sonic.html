<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HCP - Sonic Analysis</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #000;
      color: #0f0;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    #container {
      width: 90%;
      max-width: 900px;
      text-align: center;
    }

    h1 {
      font-size: 2em;
      font-weight: 300;
      letter-spacing: 0.3em;
      margin-bottom: 40px;
      text-transform: uppercase;
      text-shadow: 0 0 10px #0f0;
    }

    #file-input-container {
      margin-bottom: 60px;
    }

    #file-input {
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      padding: 10px;
      background: #000;
      color: #0f0;
      border: 1px solid #0f0;
    }

    #controls {
      display: flex;
      gap: 20px;
      justify-content: center;
      align-items: center;
      margin-bottom: 40px;
    }

    button {
      font-family: 'Courier New', monospace;
      font-size: 1em;
      padding: 15px 30px;
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      transition: all 0.2s;
    }

    button:hover:not(:disabled) {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 20px #0f0;
    }

    button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    #visualizer {
      width: 100%;
      height: 300px;
      border: 1px solid #0f0;
      margin-bottom: 40px;
    }

    #info {
      font-size: 0.9em;
      line-height: 2;
      opacity: 0.7;
    }

    #info .label {
      display: inline-block;
      width: 150px;
      text-align: right;
      margin-right: 20px;
      opacity: 0.5;
    }

    #progress {
      margin-top: 20px;
      font-size: 1.2em;
      font-weight: bold;
    }

    .hidden {
      display: none;
    }

    #waveform {
      position: relative;
      width: 100%;
      height: 300px;
      background: #000;
      border: 1px solid #0f0;
      margin-bottom: 30px;
    }

    #legend {
      font-size: 0.75em;
      opacity: 0.6;
      margin-top: 30px;
      line-height: 1.8;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    input[type="range"] {
      width: 150px;
    }

    #speed-value {
      min-width: 50px;
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>Sonic Analysis</h1>

    <div id="file-input-container">
      <input type="file" id="file-input" accept=".json">
    </div>

    <div id="controls" class="hidden">
      <button id="play-btn" disabled>▶ Play</button>
      <button id="stop-btn" disabled>■ Stop</button>
      <div class="speed-control">
        <label for="speed">Speed:</label>
        <input type="range" id="speed" min="0.5" max="8" step="0.5" value="4">
        <span id="speed-value">4x</span>
      </div>
    </div>

    <canvas id="visualizer" class="hidden"></canvas>

    <div id="info" class="hidden">
      <div><span class="label">Performance:</span><span id="perf-name">-</span></div>
      <div><span class="label">Duration:</span><span id="perf-duration">-</span></div>
      <div><span class="label">Participants:</span><span id="perf-participants">-</span></div>
      <div><span class="label">Events:</span><span id="perf-events">-</span></div>
      <div id="progress"><span class="label">Progress:</span><span id="progress-value">Ready</span></div>
    </div>

    <div id="legend" class="hidden">
      <div>SONIFICATION MAPPING:</div>
      <div><strong>Participants:</strong></div>
      <div>• Each participant = voice (filtered triangle wave)</div>
      <div>• Mapped to pentatonic scale across 3 octaves</div>
      <div>• Instruction = note attack / Completion = pitch bend + release</div>
      <div>• Stereo panning by participant position</div>
      <div><strong>Data-Derived Harmony:</strong></div>
      <div>• Bass/pad roots derived from completion time patterns</div>
      <div>• Fast avg times → higher/brighter harmony</div>
      <div>• Slow avg times → lower/darker harmony</div>
      <div>• High variance → minor intervals, more bass</div>
      <div>• Low variance → major intervals, more pad</div>
      <div><strong>Group Voicing:</strong></div>
      <div>• Large groups (>5) = major third harmonics</div>
      <div>• Medium groups (3-5) = perfect fifth harmonics</div>
      <div>• Small groups = subtle detuning</div>
      <div>• Groups >8 participants = arpeggiated attack</div>
    </div>
  </div>

  <script>
    let replayData = null;
    let audioContext = null;
    let isPlaying = false;
    let playbackSpeed = 4;
    let scheduledEvents = [];
    let activeOscillators = new Map();
    let analyser = null;
    let canvas = null;
    let canvasCtx = null;
    let animationId = null;
    let startTime = null;

    // Audio nodes
    let masterGain = null;
    let compressor = null;
    let convolver = null;

    // Sonic scaffolding elements
    let bassDrone = null;
    let ambientPad = null;
    let bassDroneGain = null;
    let ambientPadGain = null;
    let pulseOsc = null;
    let pulseGain = null;

    // Musical scale (Pentatonic C major - more pleasant)
    const pentatonicScale = [0, 2, 4, 7, 9]; // Scale degrees

    // Chord progressions (root notes for each round)
    const chordRoots = [0, 4, 7, 2, 9]; // I, IV, V, II, VI in pentatonic

    // Audio setup
    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Master gain (volume control)
        masterGain = audioContext.createGain();
        masterGain.gain.value = 0.25; // Lower to make room for scaffolding

        // Compressor (prevent clipping)
        compressor = audioContext.createDynamicsCompressor();
        compressor.threshold.value = -24;
        compressor.knee.value = 30;
        compressor.ratio.value = 12;
        compressor.attack.value = 0.003;
        compressor.release.value = 0.25;

        // Analyser
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;

        // Create simple reverb
        createReverb();

        // Connect chain: masterGain → convolver → compressor → analyser → destination
        masterGain.connect(convolver);
        convolver.connect(compressor);
        compressor.connect(analyser);
        analyser.connect(audioContext.destination);

        // Initialize sonic scaffolding
        initSonicScaffolding();
      }
    }

    function initSonicScaffolding() {
      // Bass drone - provides harmonic foundation
      bassDrone = audioContext.createOscillator();
      bassDrone.type = 'sine';
      bassDrone.frequency.value = 65.41; // C2

      bassDroneGain = audioContext.createGain();
      bassDroneGain.gain.value = 0; // Start silent

      const bassDroneFilter = audioContext.createBiquadFilter();
      bassDroneFilter.type = 'lowpass';
      bassDroneFilter.frequency.value = 150;
      bassDroneFilter.Q.value = 2;

      bassDrone.connect(bassDroneFilter);
      bassDroneFilter.connect(bassDroneGain);
      bassDroneGain.connect(masterGain);

      bassDrone.start();

      // Ambient pad - creates atmosphere
      ambientPad = audioContext.createOscillator();
      ambientPad.type = 'sawtooth';
      ambientPad.frequency.value = 130.81; // C3

      ambientPadGain = audioContext.createGain();
      ambientPadGain.gain.value = 0; // Start silent

      const padFilter = audioContext.createBiquadFilter();
      padFilter.type = 'lowpass';
      padFilter.frequency.value = 800;
      padFilter.Q.value = 0.5;

      ambientPad.connect(padFilter);
      padFilter.connect(ambientPadGain);
      ambientPadGain.connect(masterGain);

      ambientPad.start();

      // Pulse oscillator for rhythmic markers
      pulseOsc = audioContext.createOscillator();
      pulseOsc.type = 'sine';
      pulseOsc.frequency.value = 1047; // C6

      pulseGain = audioContext.createGain();
      pulseGain.gain.value = 0;

      pulseOsc.connect(pulseGain);
      pulseGain.connect(masterGain);

      pulseOsc.start();
    }

    function analyzeRoundHarmony(roundEvents) {
      // Analyze completion time patterns to find harmonic character
      const completions = roundEvents.filter(e => e.type === 'task_completed');

      if (completions.length === 0) return { root: 0, mode: 'major' };

      // Calculate completion time statistics
      const times = completions.map(c => c.data.completion_time_ms);
      const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
      const variance = times.reduce((sum, t) => sum + Math.pow(t - avgTime, 2), 0) / times.length;
      const stdDev = Math.sqrt(variance);

      // Fast average = brighter harmony (higher in scale)
      // Slow average = darker harmony (lower in scale)
      // High variance = more complex/dissonant intervals

      const timeNormalized = Math.min(avgTime / 5000, 1); // 0-1, where 1 is slow
      const varianceNormalized = Math.min(stdDev / 2000, 1); // 0-1, where 1 is high variance

      // Map average time to scale position (fast = higher, slow = lower)
      const scalePosition = Math.floor((1 - timeNormalized) * pentatonicScale.length);
      const root = pentatonicScale[scalePosition];

      // High variance suggests minor/modal quality, low variance suggests major
      const mode = varianceNormalized > 0.5 ? 'minor' : 'major';

      return { root, mode, variance: varianceNormalized };
    }

    function setRoundHarmony(roundNumber, roundData) {
      if (!audioContext || !bassDrone || !ambientPad) return;

      try {
        // Analyze the round's events to derive harmony
        const harmony = analyzeRoundHarmony(roundData.events);

        // Bass drone follows derived root
        const bassFreq = 65.41 * Math.pow(2, harmony.root / 12); // C2 + semitones

        const now = audioContext.currentTime;
        bassDrone.frequency.exponentialRampToValueAtTime(bassFreq, now + 2);

        // Ambient pad interval depends on mode
        // Major = perfect fifth (1.5x), minor = minor sixth (1.587x)
        const intervalMultiplier = harmony.mode === 'major' ? 1.5 : 1.587;
        const padFreq = bassFreq * intervalMultiplier;
        ambientPad.frequency.exponentialRampToValueAtTime(padFreq, now + 2);

        // Bass drone intensity based on variance (more variance = stronger bass foundation)
        const droneGain = 0.05 + (harmony.variance * 0.05);
        bassDroneGain.gain.cancelScheduledValues(now);
        bassDroneGain.gain.setValueAtTime(bassDroneGain.gain.value, now);
        bassDroneGain.gain.linearRampToValueAtTime(droneGain, now + 1);

        // Pad gain inversely related to variance (consonant = more pad)
        const padGain = 0.03 - (harmony.variance * 0.015);
        ambientPadGain.gain.cancelScheduledValues(now);
        ambientPadGain.gain.setValueAtTime(ambientPadGain.gain.value, now);
        ambientPadGain.gain.linearRampToValueAtTime(padGain, now + 1.5);

        console.log(`Round ${roundNumber}: Root=${harmony.root}, Mode=${harmony.mode}, Variance=${harmony.variance.toFixed(2)}`);
      } catch (error) {
        console.error('Error setting round harmony:', error);
      }
    }

    function playPulse() {
      if (!audioContext || !pulseGain) return;

      try {
        const now = audioContext.currentTime;

        // Quick click/pulse
        pulseGain.gain.cancelScheduledValues(now);
        pulseGain.gain.setValueAtTime(0, now);
        pulseGain.gain.linearRampToValueAtTime(0.03, now + 0.005);
        pulseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
      } catch (error) {
        console.error('Error playing pulse:', error);
      }
    }

    function fadeOutScaffolding() {
      if (!audioContext || !bassDroneGain || !ambientPadGain) return;

      try {
        const now = audioContext.currentTime;

        bassDroneGain.gain.cancelScheduledValues(now);
        bassDroneGain.gain.setValueAtTime(bassDroneGain.gain.value, now);
        bassDroneGain.gain.linearRampToValueAtTime(0, now + 2);

        ambientPadGain.gain.cancelScheduledValues(now);
        ambientPadGain.gain.setValueAtTime(ambientPadGain.gain.value, now);
        ambientPadGain.gain.linearRampToValueAtTime(0, now + 2);
      } catch (error) {
        console.error('Error fading out scaffolding:', error);
      }
    }

    // Create simple reverb using convolver
    function createReverb() {
      try {
        convolver = audioContext.createConvolver();

        // Create impulse response (simple reverb)
        const sampleRate = audioContext.sampleRate;
        const length = sampleRate * 2; // 2 second reverb
        const impulse = audioContext.createBuffer(2, length, sampleRate);

        for (let channel = 0; channel < 2; channel++) {
          const channelData = impulse.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
          }
        }

        convolver.buffer = impulse;
      } catch (error) {
        console.error('Error creating reverb:', error);
        // Fall back to no reverb
        convolver = audioContext.createGain();
        convolver.gain.value = 1;
      }
    }

    // Load file
    document.getElementById('file-input').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          replayData = JSON.parse(e.target.result);
          loadPerformance();
        } catch (error) {
          console.error('Error loading replay:', error);
          alert('Error loading replay file');
        }
      };
      reader.readAsText(file);
    });

    function loadPerformance() {
      console.log('Loading performance for sonification...');

      // Stop any existing playback and clean up
      if (isPlaying) {
        stopPlayback();
      }

      // Clear any lingering state
      resetState();

      initAudio();

      // Extract info
      const duration = new Date(replayData.metadata.end_time) -
                      new Date(replayData.metadata.start_time);

      document.getElementById('perf-name').textContent = replayData.metadata.name;
      document.getElementById('perf-duration').textContent = `${(duration / 1000).toFixed(1)}s`;
      document.getElementById('perf-participants').textContent = replayData.metadata.total_participants;
      document.getElementById('perf-events').textContent = replayData.events.length;

      // Show UI
      document.getElementById('controls').classList.remove('hidden');
      document.getElementById('visualizer').classList.remove('hidden');
      document.getElementById('info').classList.remove('hidden');
      document.getElementById('legend').classList.remove('hidden');
      document.getElementById('play-btn').disabled = false;
      document.getElementById('stop-btn').disabled = true;
      document.getElementById('progress-value').textContent = 'Ready';

      // Setup visualizer
      canvas = document.getElementById('visualizer');
      canvasCtx = canvas.getContext('2d');
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    }

    function resetState() {
      // Clear all scheduled events
      scheduledEvents.forEach(id => clearTimeout(id));
      scheduledEvents = [];

      // Force stop all oscillators
      activeOscillators.forEach((active, participantId) => {
        try {
          if (active.osc) {
            active.osc.onended = null; // Remove callback to prevent issues
            active.osc.stop();
          }
        } catch (e) {}
      });
      activeOscillators.clear();

      // Fade out scaffolding
      fadeOutScaffolding();

      // Stop visualization
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      // Reset playback state
      isPlaying = false;
      startTime = null;
    }

    // Speed control
    document.getElementById('speed').addEventListener('input', function(e) {
      playbackSpeed = parseFloat(e.target.value);
      document.getElementById('speed-value').textContent = `${playbackSpeed}x`;
    });

    // Play
    document.getElementById('play-btn').addEventListener('click', async function() {
      if (isPlaying) return;

      try {
        initAudio();

        if (!audioContext) {
          alert('Failed to initialize audio context');
          return;
        }

        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        isPlaying = true;
        document.getElementById('play-btn').disabled = true;
        document.getElementById('stop-btn').disabled = false;
        document.getElementById('progress-value').textContent = 'Playing...';

        sonifyPerformance();
        visualize();
      } catch (error) {
        console.error('Error starting playback:', error);
        alert('Error starting playback: ' + error.message);
        stopPlayback();
      }
    });

    // Stop
    document.getElementById('stop-btn').addEventListener('click', function() {
      stopPlayback();
    });

    function stopPlayback() {
      if (!isPlaying) {
        // Even if not playing, ensure clean state
        resetState();
        return;
      }

      isPlaying = false;

      // Cancel all scheduled events
      scheduledEvents.forEach(id => clearTimeout(id));
      scheduledEvents = [];

      // Stop all active oscillators gracefully
      const now = audioContext ? audioContext.currentTime : 0;
      activeOscillators.forEach((active, participantId) => {
        try {
          if (audioContext && active.gainNode) {
            active.gainNode.gain.cancelScheduledValues(now);
            active.gainNode.gain.setValueAtTime(active.gainNode.gain.value, now);
            active.gainNode.gain.linearRampToValueAtTime(0, now + 0.1);
          }
          if (active.osc) {
            active.osc.onended = null; // Remove callback
            active.osc.stop(now + 0.15);
          }
        } catch (e) {
          console.error('Error stopping oscillator:', e);
        }
      });
      activeOscillators.clear();

      // Stop visualization
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      startTime = null;

      document.getElementById('play-btn').disabled = false;
      document.getElementById('stop-btn').disabled = true;
      document.getElementById('progress-value').textContent = 'Stopped';
    }

    function sonifyPerformance() {
      const performanceStart = new Date(replayData.metadata.start_time);
      const now = audioContext.currentTime;
      startTime = Date.now();

      // Build participant ID to index mapping
      const participantIds = new Set();
      replayData.events.forEach(event => {
        if (event.participant_id) participantIds.add(event.participant_id);
        if (event.data?.participants) {
          event.data.participants.forEach(id => participantIds.add(id));
        }
      });
      const participantArray = Array.from(participantIds).sort();
      const participantToIndex = new Map();
      participantArray.forEach((id, index) => {
        participantToIndex.set(id, index);
      });

      // Organize events by round for harmonic analysis
      const roundsData = [];
      let currentRoundData = null;

      replayData.events.forEach(event => {
        if (event.type === 'round_start') {
          if (currentRoundData) {
            roundsData.push(currentRoundData);
          }
          currentRoundData = {
            number: event.round_number || 0,
            events: []
          };
        }
        if (currentRoundData) {
          currentRoundData.events.push(event);
        }
      });
      if (currentRoundData) {
        roundsData.push(currentRoundData);
      }

      // Schedule all events
      replayData.events.forEach(event => {
        const eventTime = new Date(event.timestamp);
        const relativeTime = (eventTime - performanceStart) / playbackSpeed;

        if (event.type === 'round_start') {
          const roundNumber = event.round_number || 0;
          const roundData = roundsData.find(r => r.number === roundNumber);
          const timeoutId = setTimeout(() => {
            setRoundHarmony(roundNumber, roundData);
          }, relativeTime);
          scheduledEvents.push(timeoutId);
        }

        if (event.type === 'instruction_sent') {
          const participants = event.data.participants || [];
          const groupSize = participants.length;

          // Play pulse for instruction
          const pulseTimeoutId = setTimeout(() => {
            playPulse();
          }, relativeTime);
          scheduledEvents.push(pulseTimeoutId);

          // Arpeggiate larger groups for harmonic clarity
          const shouldArpeggiate = groupSize > 8;
          const arpDelay = shouldArpeggiate ? 25 : 0; // milliseconds between notes

          participants.forEach((participantId, idx) => {
            const participantIndex = participantToIndex.get(participantId);
            if (participantIndex === undefined) return;

            // Schedule note-on with optional arpeggio delay
            const noteDelay = shouldArpeggiate ? (idx * arpDelay) : 0;
            const timeoutId = setTimeout(() => {
              playNote(participantId, participantIndex, participantArray.length, groupSize);
            }, relativeTime + noteDelay);

            scheduledEvents.push(timeoutId);
          });
        }

        if (event.type === 'task_completed') {
          const participantId = event.participant_id;
          const completionTime = event.data.completion_time_ms;

          const timeoutId = setTimeout(() => {
            stopNote(participantId, completionTime);
          }, relativeTime);

          scheduledEvents.push(timeoutId);
        }
      });

      // Schedule completion
      const totalDuration = (new Date(replayData.metadata.end_time) - performanceStart) / playbackSpeed;
      const completionTimeout = setTimeout(() => {
        // Mark as not playing first
        isPlaying = false;

        // Fade out scaffolding
        fadeOutScaffolding();

        // Let any remaining notes finish naturally (give 2 seconds)
        setTimeout(() => {
          // Clean up any lingering oscillators
          activeOscillators.forEach((active, participantId) => {
            try {
              if (audioContext && active.gainNode) {
                const now = audioContext.currentTime;
                active.gainNode.gain.cancelScheduledValues(now);
                active.gainNode.gain.setValueAtTime(active.gainNode.gain.value, now);
                active.gainNode.gain.linearRampToValueAtTime(0, now + 0.5);
              }
              if (active.osc) {
                active.osc.stop(audioContext.currentTime + 0.6);
              }
            } catch (e) {}
          });
          activeOscillators.clear();

          // Stop visualization
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }

          document.getElementById('play-btn').disabled = false;
          document.getElementById('stop-btn').disabled = true;
          document.getElementById('progress-value').textContent = 'Complete';
        }, 2000);
      }, totalDuration);
      scheduledEvents.push(completionTimeout);
    }

    function playNote(participantId, participantIndex, totalParticipants, groupSize = 1) {
      if (!isPlaying || !audioContext) return;

      try {
        // If a note is already playing for this participant, let it finish naturally
        const existing = activeOscillators.get(participantId);
        if (existing) {
          console.log(`Note already playing for ${participantId}, skipping duplicate`);
          return;
        }

        // Quantize to pentatonic scale
        const octaves = 3;
        const notesPerOctave = pentatonicScale.length;
        const totalNotes = octaves * notesPerOctave;

        const noteIndex = Math.floor((participantIndex / totalParticipants) * totalNotes);
        const octave = Math.floor(noteIndex / notesPerOctave);
        const scaleIndex = noteIndex % notesPerOctave;

        const baseFreq = 261.63; // C4
        const semitoneOffset = (octave * 12) + pentatonicScale[scaleIndex];
        const frequency = baseFreq * Math.pow(2, semitoneOffset / 12);

        // Create richer timbre for larger groups (chord voicings)
        const osc1 = audioContext.createOscillator();
        osc1.frequency.value = frequency;
        osc1.type = 'triangle';

        // Add harmonic richness for groups (second voice)
        const osc2 = audioContext.createOscillator();
        if (groupSize > 5) {
          // Large groups get a third above (major third ~= 1.26)
          osc2.frequency.value = frequency * 1.26;
          osc2.type = 'triangle';
        } else if (groupSize > 2) {
          // Medium groups get a fifth above
          osc2.frequency.value = frequency * 1.5;
          osc2.type = 'sine';
        } else {
          // Small groups just get slight detuning for warmth
          osc2.frequency.value = frequency * 1.005;
          osc2.type = 'triangle';
        }

        const osc1Gain = audioContext.createGain();
        const osc2Gain = audioContext.createGain();

        // Balance between voices
        osc1Gain.gain.value = 1.0;
        osc2Gain.gain.value = groupSize > 2 ? 0.4 : 0.2; // More harmonics for larger groups

        // Create filter for warmer sound
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 2000 + (groupSize * 100); // Brighter for larger groups
        filter.Q.value = 1;

        // Create gain node with envelope
        const gainNode = audioContext.createGain();

        // Stereo panning based on participant position
        const panner = audioContext.createStereoPanner();
        panner.pan.value = (participantIndex / totalParticipants) * 2 - 1;

        // ADSR Envelope - larger groups have longer attack
        const now = audioContext.currentTime;
        const attackTime = 0.02 + (groupSize * 0.005);
        const decayTime = 0.1;
        const sustainLevel = 0.012 + (groupSize * 0.002); // Louder for larger groups

        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.04, now + attackTime);
        gainNode.gain.exponentialRampToValueAtTime(Math.max(0.001, sustainLevel), now + attackTime + decayTime);

        // Connect: oscs → gains → filter → gain → panner → master
        osc1.connect(osc1Gain);
        osc2.connect(osc2Gain);
        osc1Gain.connect(filter);
        osc2Gain.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(panner);
        panner.connect(masterGain);

        osc1.start(now);
        osc2.start(now);

        // Handle oscillator end event
        osc1.onended = () => {
          activeOscillators.delete(participantId);
        };

        activeOscillators.set(participantId, {
          osc: osc1,
          osc2: osc2,
          gainNode,
          filter,
          panner,
          frequency
        });
      } catch (error) {
        console.error('Error playing note:', error);
      }
    }

    function stopNote(participantId, completionTime) {
      if (!audioContext) return;

      const active = activeOscillators.get(participantId);
      if (!active) {
        console.log(`No active note found for ${participantId}`);
        return;
      }

      try {
        const { osc, osc2, gainNode, frequency } = active;

        // Pitch shift based on completion speed
        let pitchMultiplier;
        if (completionTime < 2000) {
          pitchMultiplier = 1.5; // Fast - up a fifth
        } else if (completionTime < 5000) {
          pitchMultiplier = 1.0; // Medium - same pitch
        } else {
          pitchMultiplier = 0.75; // Slow - down a fourth
        }

        const now = audioContext.currentTime;
        const pitchBendTime = 0.1;
        const releaseTime = 0.3;

        // Cancel any scheduled changes
        osc.frequency.cancelScheduledValues(now);
        if (osc2) {
          osc2.frequency.cancelScheduledValues(now);
        }
        gainNode.gain.cancelScheduledValues(now);

        // Pitch bend both oscillators
        const currentFreq = osc.frequency.value;
        const targetFreq = currentFreq * pitchMultiplier;
        osc.frequency.setValueAtTime(currentFreq, now);
        osc.frequency.exponentialRampToValueAtTime(
          Math.max(20, targetFreq),
          now + pitchBendTime
        );

        if (osc2) {
          const currentFreq2 = osc2.frequency.value;
          const targetFreq2 = currentFreq2 * pitchMultiplier;
          osc2.frequency.setValueAtTime(currentFreq2, now);
          osc2.frequency.exponentialRampToValueAtTime(
            Math.max(20, targetFreq2),
            now + pitchBendTime
          );
        }

        // Release envelope
        const currentGain = gainNode.gain.value;
        gainNode.gain.setValueAtTime(currentGain, now);
        gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);

        // Stop oscillators after release completes
        const stopTime = now + releaseTime + 0.05;
        osc.onended = null;
        osc.stop(stopTime);
        if (osc2) {
          osc2.stop(stopTime);
        }

        // Clean up from map after stopping
        setTimeout(() => {
          activeOscillators.delete(participantId);
        }, (releaseTime + 0.1) * 1000);
      } catch (error) {
        console.error('Error stopping note:', error);
        try {
          active.osc.onended = null;
          active.osc.stop();
          if (active.osc2) active.osc2.stop();
        } catch (e) {}
        activeOscillators.delete(participantId);
      }
    }

    function visualize() {
      if (!isPlaying) return;

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      function draw() {
        if (!isPlaying) return;

        animationId = requestAnimationFrame(draw);

        analyser.getByteTimeDomainData(dataArray);

        canvasCtx.fillStyle = 'rgb(0, 0, 0)';
        canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = 'rgb(0, 255, 0)';
        canvasCtx.shadowBlur = 10;
        canvasCtx.shadowColor = 'rgb(0, 255, 0)';

        canvasCtx.beginPath();

        const sliceWidth = canvas.width / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const v = dataArray[i] / 128.0;
          const y = v * canvas.height / 2;

          if (i === 0) {
            canvasCtx.moveTo(x, y);
          } else {
            canvasCtx.lineTo(x, y);
          }

          x += sliceWidth;
        }

        canvasCtx.lineTo(canvas.width, canvas.height / 2);
        canvasCtx.stroke();

        // Update progress
        if (startTime) {
          const elapsed = (Date.now() - startTime) / 1000;
          const totalDuration = (new Date(replayData.metadata.end_time) -
                                new Date(replayData.metadata.start_time)) / 1000 / playbackSpeed;
          const progress = Math.min(100, (elapsed / totalDuration) * 100);
          document.getElementById('progress-value').textContent =
            `${progress.toFixed(1)}% (${elapsed.toFixed(1)}s / ${totalDuration.toFixed(1)}s)`;
        }
      }

      draw();
    }
  </script>
</body>
</html>
