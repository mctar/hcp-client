<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HCP - Sonic Analysis</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Courier New', monospace;
      background: #000;
      color: #0f0;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    #container {
      width: 90%;
      max-width: 900px;
      text-align: center;
    }

    h1 {
      font-size: 2em;
      font-weight: 300;
      letter-spacing: 0.3em;
      margin-bottom: 40px;
      text-transform: uppercase;
      text-shadow: 0 0 10px #0f0;
    }

    #file-input-container {
      margin-bottom: 60px;
    }

    #file-input {
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      padding: 10px;
      background: #000;
      color: #0f0;
      border: 1px solid #0f0;
    }

    #controls {
      display: flex;
      gap: 20px;
      justify-content: center;
      align-items: center;
      margin-bottom: 40px;
    }

    button {
      font-family: 'Courier New', monospace;
      font-size: 1em;
      padding: 15px 30px;
      background: #000;
      color: #0f0;
      border: 2px solid #0f0;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.2em;
      transition: all 0.2s;
    }

    button:hover:not(:disabled) {
      background: #0f0;
      color: #000;
      box-shadow: 0 0 20px #0f0;
    }

    button:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    #visualizer {
      width: 100%;
      height: 300px;
      border: 1px solid #0f0;
      margin-bottom: 40px;
    }

    #info {
      font-size: 0.9em;
      line-height: 2;
      opacity: 0.7;
    }

    #info .label {
      display: inline-block;
      width: 150px;
      text-align: right;
      margin-right: 20px;
      opacity: 0.5;
    }

    #progress {
      margin-top: 20px;
      font-size: 1.2em;
      font-weight: bold;
    }

    .hidden {
      display: none;
    }

    #waveform {
      position: relative;
      width: 100%;
      height: 300px;
      background: #000;
      border: 1px solid #0f0;
      margin-bottom: 30px;
    }

    #legend {
      font-size: 0.75em;
      opacity: 0.6;
      margin-top: 30px;
      line-height: 1.8;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    input[type="range"] {
      width: 150px;
    }

    #speed-value {
      min-width: 50px;
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>Sonic Analysis</h1>

    <div id="file-input-container">
      <input type="file" id="file-input" accept=".json">
    </div>

    <div id="controls" class="hidden">
      <button id="play-btn" disabled>▶ Play</button>
      <button id="stop-btn" disabled>■ Stop</button>
      <div class="speed-control">
        <label for="speed">Speed:</label>
        <input type="range" id="speed" min="0.5" max="8" step="0.5" value="4">
        <span id="speed-value">4x</span>
      </div>
    </div>

    <canvas id="visualizer" class="hidden"></canvas>

    <div id="info" class="hidden">
      <div><span class="label">Performance:</span><span id="perf-name">-</span></div>
      <div><span class="label">Duration:</span><span id="perf-duration">-</span></div>
      <div><span class="label">Participants:</span><span id="perf-participants">-</span></div>
      <div><span class="label">Events:</span><span id="perf-events">-</span></div>
      <div id="progress"><span class="label">Progress:</span><span id="progress-value">Ready</span></div>
    </div>

    <div id="legend" class="hidden">
      <div>SONIFICATION MAPPING:</div>
      <div>• Each participant = voice (filtered triangle wave)</div>
      <div>• Participants mapped to pentatonic scale (C major)</div>
      <div>• Instruction = note attack with ADSR envelope</div>
      <div>• Completion speed → pitch bend (fast up, slow down)</div>
      <div>• Spatial positioning → stereo panning</div>
      <div>• Signal chain: filter → reverb → compressor</div>
    </div>
  </div>

  <script>
    let replayData = null;
    let audioContext = null;
    let isPlaying = false;
    let playbackSpeed = 4;
    let scheduledEvents = [];
    let activeOscillators = new Map();
    let analyser = null;
    let canvas = null;
    let canvasCtx = null;
    let animationId = null;
    let startTime = null;

    // Audio nodes
    let masterGain = null;
    let compressor = null;
    let convolver = null;

    // Musical scale (Pentatonic C major - more pleasant)
    const pentatonicScale = [0, 2, 4, 7, 9]; // Scale degrees

    // Audio setup
    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Master gain (volume control)
        masterGain = audioContext.createGain();
        masterGain.gain.value = 0.3;

        // Compressor (prevent clipping)
        compressor = audioContext.createDynamicsCompressor();
        compressor.threshold.value = -24;
        compressor.knee.value = 30;
        compressor.ratio.value = 12;
        compressor.attack.value = 0.003;
        compressor.release.value = 0.25;

        // Analyser
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;

        // Create simple reverb
        createReverb();

        // Connect chain: masterGain → convolver → compressor → analyser → destination
        masterGain.connect(convolver);
        convolver.connect(compressor);
        compressor.connect(analyser);
        analyser.connect(audioContext.destination);
      }
    }

    // Create simple reverb using convolver
    function createReverb() {
      try {
        convolver = audioContext.createConvolver();

        // Create impulse response (simple reverb)
        const sampleRate = audioContext.sampleRate;
        const length = sampleRate * 2; // 2 second reverb
        const impulse = audioContext.createBuffer(2, length, sampleRate);

        for (let channel = 0; channel < 2; channel++) {
          const channelData = impulse.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
          }
        }

        convolver.buffer = impulse;
      } catch (error) {
        console.error('Error creating reverb:', error);
        // Fall back to no reverb
        convolver = audioContext.createGain();
        convolver.gain.value = 1;
      }
    }

    // Load file
    document.getElementById('file-input').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          replayData = JSON.parse(e.target.result);
          loadPerformance();
        } catch (error) {
          console.error('Error loading replay:', error);
          alert('Error loading replay file');
        }
      };
      reader.readAsText(file);
    });

    function loadPerformance() {
      console.log('Loading performance for sonification...');

      initAudio();

      // Extract info
      const duration = new Date(replayData.metadata.end_time) -
                      new Date(replayData.metadata.start_time);

      document.getElementById('perf-name').textContent = replayData.metadata.name;
      document.getElementById('perf-duration').textContent = `${(duration / 1000).toFixed(1)}s`;
      document.getElementById('perf-participants').textContent = replayData.metadata.total_participants;
      document.getElementById('perf-events').textContent = replayData.events.length;

      // Show UI
      document.getElementById('controls').classList.remove('hidden');
      document.getElementById('visualizer').classList.remove('hidden');
      document.getElementById('info').classList.remove('hidden');
      document.getElementById('legend').classList.remove('hidden');
      document.getElementById('play-btn').disabled = false;

      // Setup visualizer
      canvas = document.getElementById('visualizer');
      canvasCtx = canvas.getContext('2d');
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    }

    // Speed control
    document.getElementById('speed').addEventListener('input', function(e) {
      playbackSpeed = parseFloat(e.target.value);
      document.getElementById('speed-value').textContent = `${playbackSpeed}x`;
    });

    // Play
    document.getElementById('play-btn').addEventListener('click', async function() {
      if (isPlaying) return;

      try {
        initAudio();

        if (!audioContext) {
          alert('Failed to initialize audio context');
          return;
        }

        if (audioContext.state === 'suspended') {
          await audioContext.resume();
        }

        isPlaying = true;
        document.getElementById('play-btn').disabled = true;
        document.getElementById('stop-btn').disabled = false;
        document.getElementById('progress-value').textContent = 'Playing...';

        sonifyPerformance();
        visualize();
      } catch (error) {
        console.error('Error starting playback:', error);
        alert('Error starting playback: ' + error.message);
        stopPlayback();
      }
    });

    // Stop
    document.getElementById('stop-btn').addEventListener('click', function() {
      stopPlayback();
    });

    function stopPlayback() {
      isPlaying = false;

      // Cancel all scheduled events
      scheduledEvents.forEach(id => clearTimeout(id));
      scheduledEvents = [];

      // Stop all active oscillators gracefully
      const now = audioContext ? audioContext.currentTime : 0;
      activeOscillators.forEach((active, participantId) => {
        try {
          if (audioContext && active.gainNode) {
            active.gainNode.gain.cancelScheduledValues(now);
            active.gainNode.gain.setValueAtTime(active.gainNode.gain.value, now);
            active.gainNode.gain.linearRampToValueAtTime(0, now + 0.05);
          }
          if (active.osc) {
            active.osc.stop(now + 0.1);
          }
        } catch (e) {
          console.error('Error stopping oscillator:', e);
        }
      });
      activeOscillators.clear();

      // Stop visualization
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }

      document.getElementById('play-btn').disabled = false;
      document.getElementById('stop-btn').disabled = true;
      document.getElementById('progress-value').textContent = 'Stopped';
    }

    function sonifyPerformance() {
      const performanceStart = new Date(replayData.metadata.start_time);
      const now = audioContext.currentTime;
      startTime = Date.now();

      // Build participant ID to index mapping
      const participantIds = new Set();
      replayData.events.forEach(event => {
        if (event.participant_id) participantIds.add(event.participant_id);
        if (event.data?.participants) {
          event.data.participants.forEach(id => participantIds.add(id));
        }
      });
      const participantArray = Array.from(participantIds).sort();
      const participantToIndex = new Map();
      participantArray.forEach((id, index) => {
        participantToIndex.set(id, index);
      });

      // Schedule all events
      replayData.events.forEach(event => {
        const eventTime = new Date(event.timestamp);
        const relativeTime = (eventTime - performanceStart) / playbackSpeed;

        if (event.type === 'instruction_sent') {
          const participants = event.data.participants || [];

          participants.forEach(participantId => {
            const participantIndex = participantToIndex.get(participantId);
            if (participantIndex === undefined) return;

            // Schedule note-on
            const timeoutId = setTimeout(() => {
              playNote(participantId, participantIndex, participantArray.length);
            }, relativeTime);

            scheduledEvents.push(timeoutId);
          });
        }

        if (event.type === 'task_completed') {
          const participantId = event.participant_id;
          const completionTime = event.data.completion_time_ms;

          const timeoutId = setTimeout(() => {
            stopNote(participantId, completionTime);
          }, relativeTime);

          scheduledEvents.push(timeoutId);
        }
      });

      // Schedule completion
      const totalDuration = (new Date(replayData.metadata.end_time) - performanceStart) / playbackSpeed;
      const completionTimeout = setTimeout(() => {
        stopPlayback();
        document.getElementById('progress-value').textContent = 'Complete';
      }, totalDuration);
      scheduledEvents.push(completionTimeout);
    }

    function playNote(participantId, participantIndex, totalParticipants) {
      if (!isPlaying || !audioContext) return;

      try {
        // Clean up any existing note for this participant
        const existing = activeOscillators.get(participantId);
        if (existing) {
          try {
            existing.gainNode.gain.cancelScheduledValues(audioContext.currentTime);
            existing.gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            existing.osc.stop(audioContext.currentTime);
          } catch (e) {}
          activeOscillators.delete(participantId);
        }

        // Quantize to pentatonic scale
        const octaves = 3; // Spread across 3 octaves
        const notesPerOctave = pentatonicScale.length;
        const totalNotes = octaves * notesPerOctave;

        const noteIndex = Math.floor((participantIndex / totalParticipants) * totalNotes);
        const octave = Math.floor(noteIndex / notesPerOctave);
        const scaleIndex = noteIndex % notesPerOctave;

        const baseFreq = 261.63; // C4
        const semitoneOffset = (octave * 12) + pentatonicScale[scaleIndex];
        const frequency = baseFreq * Math.pow(2, semitoneOffset / 12);

        // Create oscillator with triangle wave (softer than sine)
        const osc = audioContext.createOscillator();
        osc.frequency.value = frequency;
        osc.type = 'triangle';

        // Create filter for warmer sound
        const filter = audioContext.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 2000;
        filter.Q.value = 1;

        // Create gain node with envelope
        const gainNode = audioContext.createGain();

        // Stereo panning based on participant position
        const panner = audioContext.createStereoPanner();
        panner.pan.value = (participantIndex / totalParticipants) * 2 - 1; // -1 to 1

        // ADSR Envelope
        const now = audioContext.currentTime;
        const attackTime = 0.02;
        const decayTime = 0.1;
        const sustainLevel = 0.015; // Quieter overall

        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.04, now + attackTime); // Attack
        gainNode.gain.exponentialRampToValueAtTime(Math.max(0.001, sustainLevel), now + attackTime + decayTime); // Decay to sustain

        // Connect: osc → filter → gain → panner → master
        osc.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(panner);
        panner.connect(masterGain);

        osc.start(now);

        // Handle oscillator end event
        osc.onended = () => {
          activeOscillators.delete(participantId);
        };

        activeOscillators.set(participantId, { osc, gainNode, filter, panner, frequency });
      } catch (error) {
        console.error('Error playing note:', error);
      }
    }

    function stopNote(participantId, completionTime) {
      if (!isPlaying || !audioContext) return;

      const active = activeOscillators.get(participantId);
      if (!active) return;

      try {
        const { osc, gainNode, frequency } = active;

        // Pitch shift based on completion speed
        // Fast = pitch up, slow = pitch down
        let pitchMultiplier;
        if (completionTime < 2000) {
          pitchMultiplier = 1.5; // Fast - up a fifth
        } else if (completionTime < 5000) {
          pitchMultiplier = 1.0; // Medium - same pitch
        } else {
          pitchMultiplier = 0.75; // Slow - down a fourth
        }

        const now = audioContext.currentTime;
        const pitchBendTime = 0.1;
        const releaseTime = 0.3;

        // Cancel any scheduled changes
        osc.frequency.cancelScheduledValues(now);
        gainNode.gain.cancelScheduledValues(now);

        // Pitch bend
        const currentFreq = osc.frequency.value;
        const targetFreq = currentFreq * pitchMultiplier;
        osc.frequency.setValueAtTime(currentFreq, now);
        osc.frequency.exponentialRampToValueAtTime(
          Math.max(20, targetFreq), // Ensure frequency stays above 20Hz
          now + pitchBendTime
        );

        // Release envelope (use linear for safe ramp to zero)
        const currentGain = gainNode.gain.value;
        gainNode.gain.setValueAtTime(currentGain, now);
        gainNode.gain.linearRampToValueAtTime(0, now + releaseTime);

        // Stop oscillator after release completes
        const stopTime = now + releaseTime + 0.05; // Small buffer
        osc.stop(stopTime);

        // Clean up from map (onended callback will also handle this)
        setTimeout(() => {
          activeOscillators.delete(participantId);
        }, (releaseTime + 0.1) * 1000);
      } catch (error) {
        // If anything fails, force cleanup
        console.error('Error stopping note:', error);
        try {
          active.osc.stop();
        } catch (e) {}
        activeOscillators.delete(participantId);
      }
    }

    function visualize() {
      if (!isPlaying) return;

      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);

      function draw() {
        if (!isPlaying) return;

        animationId = requestAnimationFrame(draw);

        analyser.getByteTimeDomainData(dataArray);

        canvasCtx.fillStyle = 'rgb(0, 0, 0)';
        canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

        canvasCtx.lineWidth = 2;
        canvasCtx.strokeStyle = 'rgb(0, 255, 0)';
        canvasCtx.shadowBlur = 10;
        canvasCtx.shadowColor = 'rgb(0, 255, 0)';

        canvasCtx.beginPath();

        const sliceWidth = canvas.width / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
          const v = dataArray[i] / 128.0;
          const y = v * canvas.height / 2;

          if (i === 0) {
            canvasCtx.moveTo(x, y);
          } else {
            canvasCtx.lineTo(x, y);
          }

          x += sliceWidth;
        }

        canvasCtx.lineTo(canvas.width, canvas.height / 2);
        canvasCtx.stroke();

        // Update progress
        if (startTime) {
          const elapsed = (Date.now() - startTime) / 1000;
          const totalDuration = (new Date(replayData.metadata.end_time) -
                                new Date(replayData.metadata.start_time)) / 1000 / playbackSpeed;
          const progress = Math.min(100, (elapsed / totalDuration) * 100);
          document.getElementById('progress-value').textContent =
            `${progress.toFixed(1)}% (${elapsed.toFixed(1)}s / ${totalDuration.toFixed(1)}s)`;
        }
      }

      draw();
    }
  </script>
</body>
</html>
